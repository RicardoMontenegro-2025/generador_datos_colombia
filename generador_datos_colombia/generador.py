# -*- coding: utf-8 -*-
"""Untitled1.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1iOx2IbnFYBU_vlYrNo6r49GhgXQ4f_k1
"""

import random
import datetime
from datetime import date, timedelta # Importar date y timedelta específicamente
import uuid
# pprint ya no es necesario aquí, se usaba solo para mostrar

# --- Listas de datos de ejemplo (Constantes del módulo) ---
# (Mantenemos estas listas fuera de la función principal para que no se recreen cada vez)
NOMBRES = ["Sofía", "Mateo", "Valentina", "Santiago", "Isabella", "Sebastián", "Camila", "Matías", "Valeria", "Nicolás", "Luciana", "Samuel", "Mariana", "Benjamín", "Gabriela", "Thiago", "Martina", "Daniel", "Mía", "Joaquín"]
APELLIDOS = ["González", "Rodríguez", "Gómez", "Fernández", "López", "Martínez", "Pérez", "Sánchez", "Romero", "García", "Díaz", "Vásquez", "Castro", "Suárez", "Ramírez", "Flores", "Benítez", "Acosta", "Medina", "Herrera"]
GENEROS = ["Masculino", "Femenino", "Otro", "Prefiere no decir", None]
DEPARTAMENTOS = ["Antioquia", "Valle del Cauca", "Cundinamarca", "Atlántico", "Santander", "Bolívar", "Nariño", "Cauca", "Tolima", "Boyacá", None]
MUNICIPIOS_POR_DEPTO = {
    "Antioquia": ["Medellín", "Bello", "Itagüí", "Envigado", None],
    "Valle del Cauca": ["Cali", "Buenaventura", "Palmira", "Tuluá", None],
    "Cundinamarca": ["Bogotá D.C.", "Soacha", "Zipaquirá", "Facatativá", None],
    "Atlántico": ["Barranquilla", "Soledad", "Malambo", None],
    "Santander": ["Bucaramanga", "Floridablanca", "Girón", None],
    "Bolívar": ["Cartagena", "Magangué", None],
    "Nariño": ["Pasto", "Tumaco", "Ipiales", None],
    "Cauca": ["Popayán", "Santander de Quilichao", None],
    "Tolima": ["Ibagué", "Espinal", None],
    "Boyacá": ["Tunja", "Duitama", "Sogamoso", None],
    None: [None]
}
ESTADOS_CIVILES = ["Soltero/a", "Casado/a", "Unión libre", "Divorciado/a", "Viudo/a", None]
NIVELES_EDUCATIVOS = ["Ninguno", "Primaria incompleta", "Primaria completa", "Secundaria incompleta", "Secundaria completa", "Técnico/Tecnólogo", "Universitario incompleto", "Universitario completo", "Postgrado", None]
OCUPACIONES = ["Estudiante", "Empleado/a", "Independiente", "Desempleado/a", "Hogar", "Pensionado/a", "Incapacitado/a", None]
TIPOS_AFILIACION_SALUD = ["Contributivo", "Subsidiado", "Especial", "No afiliado", None]
ETNIAS = ["Ninguna", "Indígena", "Afrocolombiano/a", "Raizal", "Palenquero/a", "Gitano/a (Rrom)", None]
DISCAPACIDADES = ["Ninguna", "Física", "Visual", "Auditiva", "Intelectual", "Psicosocial", "Múltiple", None]
BOOLEANOS_CON_NONE = [True, False, None]
ESTRATOS = [1, 2, 3, 4, 5, 6, None]

# --- Función auxiliar para generar listas con Nones ---
def _generar_lista_datos(generador_o_lista, num_elementos, probabilidad_none=0.1):
    """Genera una lista de datos, permitiendo valores None. (Función interna)"""
    lista = []
    opciones_validas_cache = None # Cache para listas
    if isinstance(generador_o_lista, list):
        opciones_validas_cache = [opt for opt in generador_o_lista if opt is not None]

    for _ in range(num_elementos):
        if random.random() < probabilidad_none:
            lista.append(None)
        else:
            if callable(generador_o_lista):
                lista.append(generador_o_lista())
            elif isinstance(generador_o_lista, list):
                if opciones_validas_cache:
                    lista.append(random.choice(opciones_validas_cache))
                else:
                    lista.append(None)
            else:
                lista.append(generador_o_lista)

    if probabilidad_none > 0 and num_elementos > 0 and not any(x is None for x in lista):
        if num_elementos > 0: # Asegurar índice válido
             indice_aleatorio = random.randint(0, num_elementos - 1)
             # Solo reemplaza si hay más de un elemento o el único elemento no es None
             if num_elementos > 1 or lista[indice_aleatorio] is not None:
                 lista[indice_aleatorio] = None


    while len(lista) < num_elementos:
        lista.append(None) # Rellenar si es necesario (poco probable)
    return lista[:num_elementos]

# --- Generadores específicos auxiliares ---
def _generar_fecha_nacimiento_en_rango(start_date_dt, end_date_dt):
    """Genera una fecha de nacimiento aleatoria dentro del rango dado."""
    try:
        time_between_dates = end_date_dt - start_date_dt
        days_between_dates = time_between_dates.days
        if days_between_dates < 0:
             # print("Advertencia: days_between_dates es negativo.") # Evitar prints en librería
             return date(1980,1,1).strftime('%Y-%m-%d') # Fecha por defecto

        random_number_of_days = random.randrange(days_between_dates + 1)
        random_date = start_date_dt + timedelta(days=random_number_of_days)
        return random_date.strftime('%Y-%m-%d')
    except ValueError as e:
        # print(f"Error generando fecha: {e}. Usando fecha por defecto.") # Evitar prints
        return date(1980, 1, 1).strftime('%Y-%m-%d')

def _generar_cedula():
    return str(random.randint(10_000_000, 1_200_000_000))

def _generar_direccion():
    tipos_via = ["Calle", "Carrera", "Avenida", "Diagonal", "Transversal"]
    letras = ["", "A", "B", "C", "Bis"]
    numeros = lambda: random.randint(1, 150)
    return f"{random.choice(tipos_via)} {numeros()} {random.choice(letras)} # {numeros()} - {numeros()}"

def _generar_ingresos():
    salario_minimo_aprox = 1300000
    if random.random() < 0.15: return 0
    return random.randint(int(salario_minimo_aprox * 0.5), int(salario_minimo_aprox * 8))

def _generar_timestamp_actualizacion():
    now = datetime.datetime.now()
    start_time = now - timedelta(days=730)
    random_time = start_time + timedelta(seconds=random.randint(0, int((now - start_time).total_seconds())))
    return random_time.strftime('%Y-%m-%d %H:%M:%S')

# --- Función auxiliar para Calcular Edad ---
def _calcular_edad(fecha_nac_str, fecha_referencia):
    """Calcula la edad en años cumplidos. (Función interna)"""
    if fecha_nac_str is None: return None
    try:
        fecha_nac_dt = datetime.datetime.strptime(fecha_nac_str, '%Y-%m-%d').date()
        edad = fecha_referencia.year - fecha_nac_dt.year - ((fecha_referencia.month, fecha_referencia.day) < (fecha_nac_dt.month, fecha_nac_dt.day))
        return edad
    except ValueError:
        return None
def imprimir(data):


    cla_list = list(data.keys())
    longitudes = [len(data[cla]) for cla in cla_list]



    ancho_columnas = {cla: max(len(cla), max((len(str(item)) for item in data[cla]), default=0)) + 2 for cla in cla_list}

    # Imprimir encabezado
    encabezado = " | ".join(f"{cla:<{ancho_columnas[cla]}}" for cla in cla_list)
    print(encabezado)
    print("-" * len(encabezado))

    # Imprimir filas
    num_filas = longitudes[0]
    for i in range(num_filas):
        fila = " | ".join(f"{str(data[cla][i]):<{ancho_columnas[cla]}}" for cla in cla_list)
        print(fila)

# --- FUNCIÓN PRINCIPAL DE LA LIBRERÍA ---
def crear_base_datos_simulada(num_registros=43, edad_min=5, edad_max=87):
    """
    Genera un diccionario simulando una base de datos con datos demográficos
    aleatorios para un número específico de registros y rango de edad.

    Args:
        num_registros (int): Número de filas (registros) a generar.
        edad_min (int): Edad mínima para los registros generados.
        edad_max (int): Edad máxima para los registros generados.

    Returns:
        dict: Un diccionario donde cada clave es una columna (ej: 'Nombre')
              y cada valor es una lista de datos para esa columna.
              Retorna un diccionario vacío si num_registros <= 0.
    """
    if num_registros <= 0:
        return {}

    # --- Fecha Actual y Rango de Nacimiento (Calculado cada vez que se llama) ---
    today = date.today()
    try:
        start_date_dt = today.replace(year=today.year - (edad_max + 1)) + timedelta(days=1)
        end_date_dt = today.replace(year=today.year - edad_min)
        if start_date_dt >= end_date_dt:
             # Fallback si las edades son inválidas
            start_date_dt = today.replace(year=today.year - 88) + timedelta(days=1)
            end_date_dt = today.replace(year=today.year - 5)
            if start_date_dt >= end_date_dt: # Si aún falla, usar fechas fijas
                start_date_dt = date(today.year-87,1,1)
                end_date_dt = date(today.year-5,12,31)

    except ValueError: # Puede ocurrir cerca de años bisiestos o fechas extremas
         start_date_dt = date(today.year-87,1,1)
         end_date_dt = date(today.year-5,12,31)


    # --- Creación del diccionario (Base de Datos Simulada) ---
    db = {}

    # 1. ID único
    db['ID_Registro'] = [str(uuid.uuid4()) for _ in range(num_registros)]

    # 2. Cédula
    db['Cedula'] = _generar_lista_datos(_generar_cedula, num_registros, 0.05)

    # 3. Nombre
    db['Nombre'] = _generar_lista_datos(NOMBRES, num_registros, 0.02)

    # 4. Primer Apellido
    db['Apellido_Paterno'] = _generar_lista_datos(APELLIDOS, num_registros, 0.02)

    # 5. Segundo Apellido
    db['Apellido_Materno'] = _generar_lista_datos(APELLIDOS, num_registros, 0.15)

    # 6. Fecha de Nacimiento
    # Pasamos las fechas calculadas a la función auxiliar
    lista_fechas_nacimiento = _generar_lista_datos(lambda: _generar_fecha_nacimiento_en_rango(start_date_dt, end_date_dt), num_registros, 0.05)
    db['Fecha_Nacimiento'] = lista_fechas_nacimiento

    # 7. Edad (Calculada a partir de Fecha_Nacimiento y 'today')
    lista_edades = [_calcular_edad(fecha_str, today) for fecha_str in lista_fechas_nacimiento]
    db['Edad'] = lista_edades

    # 8. Género
    db['Genero'] = _generar_lista_datos(GENEROS, num_registros, 0.08)

    # 9. Departamento
    lista_deptos = _generar_lista_datos(DEPARTAMENTOS, num_registros, 0.1)
    db['Departamento'] = lista_deptos

    # 10. Municipio (Dependiente)
    lista_municipios = []
    for depto in lista_deptos:
        opciones_municipio = MUNICIPIOS_POR_DEPTO.get(depto, [None])
        if not isinstance(opciones_municipio, list): opciones_municipio = [None]
        opciones_validas = [m for m in opciones_municipio if m is not None]
        if opciones_validas and random.random() > 0.05:
            municipio = random.choice(opciones_validas)
        else:
            municipio = None
        lista_municipios.append(municipio)
    for i in range(len(lista_municipios)): # Nones adicionales
        if random.random() < 0.05: lista_municipios[i] = None
    db['Municipio'] = lista_municipios[:num_registros]

    # 11. Dirección
    db['Direccion'] = _generar_lista_datos(_generar_direccion, num_registros, 0.2)

    # 12. Estrato Socioeconómico
    db['Estrato_Socioeconomico'] = _generar_lista_datos(ESTRATOS, num_registros, 0.1)

    # 13. Estado Civil
    db['Estado_Civil'] = _generar_lista_datos(ESTADOS_CIVILES, num_registros, 0.07)

    # 14. Número de Hijos
    db['Numero_Hijos'] = _generar_lista_datos(lambda: random.randint(0, 8), num_registros, 0.1)

    # 15. Número de Personas en el Hogar
    db['Personas_Hogar'] = _generar_lista_datos(lambda: random.randint(1, 10), num_registros, 0.06)

    # 16. Nivel Educativo
    db['Nivel_Educativo'] = _generar_lista_datos(NIVELES_EDUCATIVOS, num_registros, 0.05)

    # 17. Ocupación
    db['Ocupacion'] = _generar_lista_datos(OCUPACIONES, num_registros, 0.08)

    # 18. Ingresos Mensuales
    db['Ingresos_Mensuales'] = _generar_lista_datos(_generar_ingresos, num_registros, 0.18)

    # 19. Trabaja Actualmente
    db['Trabaja_Actualmente'] = _generar_lista_datos(BOOLEANOS_CON_NONE, num_registros, 0.05)

    # 20. Tipo Afiliación Salud
    db['Tipo_Afiliacion_Salud'] = _generar_lista_datos(TIPOS_AFILIACION_SALUD, num_registros, 0.04)

    # 21. Pertenencia Étnica
    db['Etnia'] = _generar_lista_datos(ETNIAS, num_registros, 0.03)

    # 22. Presenta alguna Discapacidad
    db['Tiene_Discapacidad'] = _generar_lista_datos(BOOLEANOS_CON_NONE, num_registros, 0.06)

    # 23. Tipo de Discapacidad
    lista_tipos_discap = []
    tiene_discap_lista = db['Tiene_Discapacidad']
    opciones_discap = [d for d in DISCAPACIDADES if d not in ["Ninguna", None]]
    for i in range(num_registros):
        tiene_discap = tiene_discap_lista[i]
        if tiene_discap is True:
            if random.random() < 0.15 or not opciones_discap:
                lista_tipos_discap.append(None)
            else:
                lista_tipos_discap.append(random.choice(opciones_discap))
        elif tiene_discap is False:
            lista_tipos_discap.append("No aplica")
        else:
            lista_tipos_discap.append(None)
    db['Tipo_Discapacidad'] = lista_tipos_discap[:num_registros]

    # 24. Habla Lengua Indígena
    db['Habla_Lengua_Indigena'] = _generar_lista_datos(BOOLEANOS_CON_NONE, num_registros, 0.05)

    # 25. Fecha de última actualización (Opcional)
    # db['Ultima_Actualizacion'] = _generar_lista_datos(_generar_timestamp_actualizacion, num_registros, 0.01)

    return db

# --- Bloque para probar la función si ejecutas este archivo directamente ---
if __name__ == '__main__':
    import pprint # Importar pprint solo para la prueba
    print("Ejecutando prueba de generador.py...")
    # Usar la fecha actual del sistema para la prueba
    datos_prueba = crear_base_datos_simulada(num_registros=10)
    print(f"Generados {len(datos_prueba.get('ID_Registro', []))} registros.")
    print(f"Columnas generadas: {list(datos_prueba.keys())}")

    print("\n--- Vista parcial de la Base de Datos Simulada (Prueba) ---")
    claves_a_mostrar = ['ID_Registro', 'Fecha_Nacimiento', 'Edad', 'Nombre']
    vista_parcial = {}
    for clave in claves_a_mostrar:
         # Asegurarse de que la clave existe antes de intentar accederla
         if clave in datos_prueba:
              vista_parcial[clave] = datos_prueba[clave][:5] # Mostrar solo 5
         else:
              vista_parcial[clave] = ["(Clave no generada)"] * 5
    pprint.pprint(vista_parcial, width=100)

    # Verificación de edad simple
    print("\nVerificando edad vs fecha nac (primeros 5):")
    today_test = date.today()
    for i in range(min(5, len(datos_prueba.get('ID_Registro', [])))):
        fecha_nac_str = datos_prueba['Fecha_Nacimiento'][i]
        edad_gen = datos_prueba['Edad'][i]
        edad_recalc = _calcular_edad(fecha_nac_str, today_test) if fecha_nac_str else None
        print(f"  Registro {i}: Nac='{fecha_nac_str}', EdadGen={edad_gen}, EdadRecalc={edad_recalc}")
